# chapter 11

**引用和拷贝构造函数**



## 引用

**引用就像是能自动被编译器间接引用的 `常量型指针`**

通常用于函数的**参数列表** 和  函数的**返回值**中，但是也可以独立**使用。**

* 引用必须和存储单元联系
* 访问引用时，就是在访问那个存储单元
* 引用创建时，必须被初始化（指针可以在任何时候别初始化）
* 一旦一个引用初始化指向了一个对象，那他在整个生命周期内不能指向其它对象
* 不可能有NULL 引用
* 上面三个可以看出（**引用像是 常量型指针**）



**引用的类型**

* 常量引用
* 指针引用
* 一般引用



**常量引用**

* 在函数参数中使用常量引用非常重要。（因为函数可能会接收临时对象，这个临时对象是由其它函数返回的，临时对象总是不变的）

```c++
void f(int&){}
void g(const int &){}
int main(){
  f(1); // 会报错：涉及到了临时对象
  g(1);
}
```



**指针引用**

```c++
void f(int **){} // 如果想改变指针的内容，而不是指针指向的内容，应该这么玩
void g(int *& i){} // 指针引用， i是个引用，引用的是一个 int 指针。
int main(){
  int i = 47;
  int *ip = &i;
  f(&ip);
  g(ip); // 和上面的一样
}


```



## 拷贝构造函数

* 在 C/C++ 中，参数是从右向左进栈的，然后调用函数
* 函数的返回值 放在寄存器中。
* 但是这样的话，对于用户自定义的类型如何返回呢？用户自定义的类型可能是非常大，一个寄存器放不下



**函数调用栈框架**

当编译器为函数调用产生代码时：

* 将所有的参数压栈（从右向左）
* 然后调用函数
  * 在CALL中，CPU把程序代码中的**函数调用指令的地址压栈** .return 时，可以用这个地址返回到调用点。
* 在函数内部，产生代码，向下移动栈指针为函数局部变量提供存储单元



**如果返回值过大，寄存器放不下怎么办**

* 将**返回值的地址**像一个函数参数一样**压栈**
* 让函数直接把返回值信息拷贝到目的地。



**拷贝函数的作用是：从已有的对象中创建新的对象！！！**

* 如果没有手动创建 拷贝构造函数，则执行 位拷贝



**拷贝构造函数 VS 赋值运算符**

* 初始化一个 对象的时候
* 给一个对象赋值的时候



```c++
class X{
  X(const X& x){ //一定要是引用，否则会导致 死循环！！！！！
    
  }
}
```

