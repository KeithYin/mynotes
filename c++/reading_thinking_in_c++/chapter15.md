# chapter 15

**多态性与虚函数**



## 多态性

**什么是多态性**

* 提供了接口与实现的又一层隔离
* 指向父类对象的指针，调用的函数可能是 子类的方法

**向上类型转换**

取一个对象的地址（指针或引用）。并将其作为基类的地址进行处理，这被称为向上类型转换（up-casting），因为继承树的绘制方式是以基类为顶点的。



## 函数调用捆绑

* 捆绑：把函数体与函数调用相联系 称为 捆绑

**早捆绑：**

* 捆绑在程序运行之前（由编译器和连接器）完成。

**晚捆绑：**

* 捆绑在程序运行时



**疑问**

捆绑的意思应该就是 地址的 绑定吧！



## 虚函数

为了引起晚捆绑，C++要求在基类中声明这个函数时使用 `virtual` 关键字。

* 基类中声明一下就可以了
* 声明上加上即可，定义时就不需要了（派生类可以加 virtual， 也可以不加）
* 如果一个函数在基类中是 `virtual` 的，那么它在所有的派生类中都是 `virtual` 的。
* 在 派生类中 `virtual` 函数的重定义常称为 `overriding`





**纯虚函数**

* 只需将类中放置一个 纯虚函数，基类就会变成 抽象类（*abstract class*）
* 纯抽象类：类中全是纯抽象函数
* 抽象类不能实例化！！！

```c++
class Base{
  public:
  virtual void say(){
    // do something
  }
  virtual void fly() = 0; 
}
```

* 纯虚定义（纯虚函数也可以提供定义）

```c++
class Base{
  public:
  virtual void say(){
    // do something
  }
  virtual void fly() = 0; 
  // virtual void fly()=0 {} illegal! 纯虚函数的定义不能是 inline 的
}
void Base::fly(){} // 非 inline 的定义是可以接受的

class Bird: public Base{
  public:
  void fly(){Base::fly();} // 用实现好的
}
```





## C++如何实现的晚捆绑

* 典型的编译器， **为每个包含虚函数的类创建一个表（VTABLE）**
* 在 **VTABLE** 中，编译器放置特定类的虚函数地址
* 在每个带有虚函数的类中，编译器秘密地放置一个指针，称为 `vpointer`，指向这个对象的 VTABLE
* 当通过基类指针做虚函数调用时，编译器静态地插入一些代码
* 这些代码用来 获取这个 VPTR，并在 VTABLE 表中查找函数地址的代码
* 这样就能调用正确的函数并引起晚捆绑的发生



**晚捆绑的实现总结起来是：**

* 为每个类设置 VTABLE
* 初始化 VPTR
* 为虚函数调用插入代码




## 析构函数与 虚析构函数

* 构造函数是不能为虚函数的
* 析构函数常常 **必须是虚的**
  * `delete objPtr` 需要调用正确的析构函数



**虚机制在 构造函数中不能工作，被调用的只能是这个函数的本地版本。**



