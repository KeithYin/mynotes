# C++ 中的右值与左值

## 右值与左值

* 右值：**只能出现** 在 等式 右边的值。
* 左值：**可以出现** 在 等式左边的值。




## 右值引用 与 左值引用

* 左值引用：**左值的引用**

```c++
int i = 0;
int &j = i;
```

上面代码中， `i` 是一个左值，因为 它既可以在等式的右边，也可以在等式的左边。`int &j=i;` 正确的表述应为：获得 `i` 的 左值引用。



* 右值 **引用**：**首先也是引用**（获得右值的引用，只能绑定到将要销毁的对象。即：右值引用只能绑定到 右值上。）右值引用窃取了即将被销毁的对象的状态 (**右值引用只是延时了临时对象的析构函数调用时间**)。
  * 右值引用常用在 移动构造函数中

```c++
int i = 10;

// 这种用法没有现实意义, 因为右值引用, 会创建临时对象 (调用一次构造函数), 语句过后, 临时对象不会销毁.
// 如果使用 int j, 也是只会调用一次 构造函数 (j的地址压到函数里, 然后在j的地址上构造)
int &&j = i*100; 

// 常用在 移动构造函数的形参 和 普通函数的形参上.
/*
	移动构造函数的形参 (主要是这个作用)
	普通函数的形参: 由于左值引用不能用在右值上, 所以如果对于右值 不想值传递的话, 那就用 右值引用吧.
	返回一个右值引用的理解:
		也是为了正确 调用 接收对象的 移动构造函数.
		如果返回的是个左值的话, 调用的就是赋值构造函数
		如果返回的是个右值的话, 调用的就是移动构造函数
*/
```

对于一个有返回值的表达式来说，如果这个表达式的返回值没有对象来接收，他会创建一个临时对象，**这个对象在语句结束后就会被销毁**。 所以 `i*100` 返回一个 右值。 所以 `int &&j = i*100;` 就是 `j` 获得了 `i*100` 的右值引用。



```c++
int i = 42;
int &r = i;
int &&rr = i; // 错误：i 是左值
int &r2 = i*42; // 错误，i*42 是右值
const int & r3 = i*42; // 正确，可以将 const 引用绑定到右值上, 因为临时变量(右值)是 const 的?
int &&rr2 = i*42; // 正确 ， i*42 是右值
int && obj2 = func_return_obj(); // 右值引用可以使得 析构函数到 obj2 销毁的时候再执行.
```



## move 函数

虽然不能将 右值引用直接绑定到 一个 左值上，但是我们可以显示的将一个 左值转换成对应的 右值引用类型。

* move 之后，可以对源对象进行 销毁，赋值。**但是不能直接用**

```c++
int ii = 111;
// 虽然我们有一个左值，但是我们希望像右值一样对待它
int && j = std::move(ii); // move 之后就变成了一个 右值, 就可以用  右值引用 引用之
// 上面 这个 操作之后，除了对 ii 赋值 或者 销毁 它， 我们将不再用它。
```



## 移动构造函数 和 移动赋值运算符

**移动构造函数，移动赋值运算符需要做的事情**

* 完成 **资源移动**  (**利用右值引用 延迟资源 释放时间的 性质**)
* 确保移动后的源对象处于 **销毁无害的** 状态
  * 即：清理干净 源对象

```c++
StrVec::StrVec(StrVec&& s) noexcept // 移动操作不应该抛出任何异常
  : elements(s.elements), first_free(s.first_free), cap(s.cap){
    // 顶 s 进入这样的状态--对其运行析构函数是安全的
    s.elements=s.first_free=s.cap=nullptr;
  }
```

```c++
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
  {
    if (this!=&rhs){
      free(); //释放已有元素
      elemets = rhs.elements; // 从 rhs 中接管资源。
      ...;
      ...;
      // 将 rhs 处于 析构状态。
      rhs.elements=rhs.first_free=rhs.cap=nullptr;
    }
  }
```



**注意**

* 如果没有定义右值构造函数，那么对于 `move` ，编译器将执行 `copy`
* 