* 参数传递 (形参如此)
  * 可以为 `nullptr`
  * 不为`nullptr`
    * 可被修改： (`X&` 或者 `X*`)
    * 不能修改: 
      * 不能 move：(`const X&`)
      * 可以move （子函数是否需要保存该对象）：
        * 不保存（`const X&`）
        * 要保存（`X`）



```c++
// 可以为 nullptr 只读参数
void func(const Widget* const widget);
// 可以为 nullptr，可被修改的参数
void func(const Widget* const widget);

// 不为 nullptr，可被修改的参数
void func(Widget& widget);

// 不为 nullptr，不可被修改, 不可move
void func(const Widget& widget);



/* 要保存的话，pass by value
分为两种情况讨论：实参是左值，实参是右值
*/
class A {
  void func1(Widget widget) {
      widget_ = std::move(widget);
  }
  void func2(const Widget& widget) {
      widget_ = widget;
  }
};
int main() {
    Widget widget;
    A a;
    a.func1(widget); //1次copy，1次move
    a.func2(widget); // 1次copy
    
    a.func1(std::move(widget)); // 2次move
    a.func2(std::move(widget)); // 1次copy
}
```



# 智能指针作为形参

* `unique_ptr<T>`

```c++
// unique_ptr<T>, 语义：将 obj 的owner转移给 func
void func(std::unique_ptr<T> object) {}

// 如果某个函数只是想 修改某个对象，或者读某个对象，对于 ownership不感兴趣。那么函数形参就不该带着智能指针。按照普通的形参配就可以了。

// 什么时候使用 std::unique_ptr<T> &obj 作为形参。用于工厂模式的场合
void func(std::unique_ptr<T>& obj) {
    obj = std::make_unique<std::string>(); // 这个代码有问题吧。。。。
}

```

* `shared_ptr<T>` :  共享 `ownership`： 父函数和子函数共享 `ownership`
  * 如果真的不需要共享 ownership，那就不需要传智能指针
  * 什么时候传 `const std::shared_ptr<T>&` ：需要分享`ownership` 但是又不能move

```c++

```

