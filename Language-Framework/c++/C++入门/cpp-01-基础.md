# C 基础



**复杂变量声明 & 复杂类型声明**

```c++
// 从变量名开始，先右碰到 右括号，往左，碰到左括号往右。。。


// 变量 a，是个 10 元素的数组
// 数组中的元素是指针
// 指针指向的是 int 类型
int *a[10];

// 变量b，是指针
// 指向 一个包含 10 元素的数组
// 数组中元素类型为 int
int (*b)[10];



// 复杂类型定义，多了个 typedef
// 编译器看到 typedef，就会将 A 看做 类型，而不是变量


// A 是一个类型,是一个 10 元素的数组类型
// 数组中保存的是 int 指针。
typedef int *A[10];
```







* 数组名是个**常量指针**

```c++
void demo(int a[]); // 即使说明是数组，C++ 也会将其看做指针
void demo2(int *a); // 等价
```

* 数据类型的本质是：**固定大小的内存块的别名**

```c++
// 神奇的数组，指针的类型不一样，+1 的步长就会不一样

int a[5] = {1,2,3,4}
// a 表示数组第一个元素的地址，a+1 为数组第二个元素的地址
// &a 表示数组的地址，&a + 1 为整个数组之后地址
// 可以看出，不同的指针类型对 + 运算符进行了重载，+1 意味着地址移动了类型大小的字节
```

* 变量的本质：代表内存中一块连续的空间的别名
* **指针也是一个数据类型**
* 注意野指针：当指针指向的空间被 `free` 的时候，指针的值记得也要释放 `p=NULL;`
* 字符串常量：`"hello world"` ，字符串常量在 C++ 中是放在 全局常量区中的
  * `char *p = "hello world";` ，字符串常量会返回内存空间首地址
* 字面值：`10`, 这种值不知道放在哪的。
* 一级指针：**间接赋值，修改指针指向的内存空间的值**
* 二级指针：**间接修改一集指针的值**
  * 一般是需要函数内 需要用 `malloc` 分配内存空间才使用 二级指针作为形参。
* **C风格的字符串**：必须以 `\0` 结尾的字符数组



* 数组作为函数参数的退化问题

```c++
// 一维数组作为形参会退化为指针！！！
// 无论形参是什么形式（int a[5], int a[]），函数体内将其认为是指针
// 因为 int a[5], a表示的数组中第一个元素的地址。a是指针，指向的是数组第一个元素
void func(int a[]){}

// 二维数组的退化,a 是一个数组，里面有三个元素，每个元素都是长度为 5 的int数组
// 所以： a 是指向数组第一个元素的指针，a+1 会跳5个元素
void func1(int a[3][5]){}
void func2(int a[][5]){}
void func3(int (*a)[5]){}

// 指针数组, 因为a 是个 5元素的数组，元素的类型是指针
// 由于 a 表示数组第一个元素的地址，所以 a 是 int ** 类型的！！！！
void func4(int *a[5]){}
void func5(int **a){}


// main
int main(int argc, char *argv[], char** env){}
```

* C 中的 `0`

```c++
// 这三个都可以作为数组指针的结束标志。 '\0' == 0 == NULL
char * val[] = {
    "hello",
    "world",
    '\0'
};

char *val2[]={
    "hello",
    "world",
    0
}
char *val3[]={
    "hello",
    "world",
    NULL
};
```





## 内存四区模型

* 当双击 `.exe` 的时候，OS 将程序（物理硬盘上的代码）加载到内存
* 在加载到内存的过程中，操作系统将 C 代码分成四个区
  * 堆：一般由程序员分配和释放
  * 栈：编译器分配与释放，函数栈空间
  * 全局区：由操作系统管理
  * 代码区：存放函数代码
*  找到 `main()` 函数的入口
* 系统只会给一个应用程序建立一个内存四区



## 函数调用模型

**压栈流程**

* 主调函数的运行状态压栈
* 返回地址压栈
* 函数参数压栈



## 其它

* 类型别名：`typedef old_name new_name`
* `void*` 类型的指针可以接收任何类型的指针，不存在 `void` 类型的变量