# chapter 4 工厂模式



> 实例化这个活动并不应该总是公开的进行
>
> 初始化经常造成耦合问题.
>
> 工厂方法将 **实例化的代码单独封装起来** , 就是个函数(方法)

* 方法一: 将实例化的代码单独封装成一个静态方法
* 方法二: 如果还有其它交互, 比如书中提到的 Pizza 和 PizzaStore, 也可以在PizzaStore中提供抽象的`工厂方法`, 然后由其子类来实现. 
  * 方法里面也就是一大堆 `if ... else ...` 逻辑



## 设计原则

* 依赖抽象, 不要依赖具体类
  * 变量不要持有具体类的引用
  * 不要让类派生于具体类
  * 不要覆盖基类中已实现的方法

## 设计模式

* **工厂方法模式**
  * 基类定义了一个创建对象的 抽象方法, 由子类来决定到底如何创建对象
  * 场景:
    *  有不同的pizza,
    *  不同的pizza商店生产不同的pizza,
    *  不同的 pizza店 对于 pizza 的制作流程不同
  * 方案: 创建一个 pizza store 的接口, 里面留下来两个方法由用户自定义.
    * 用户继承 pizza store 接口, 自己实现自己的 制作流程的 pizza 制造



* **抽象工厂方法模式**
  * 提供一个接口,用于创建相关或者依赖对象的家族, 而不需要明确指定具体了类
  * 和上个方法的不同点
    * 工厂方法是一个 **函数/方法** 负责创建具有相同基类的一个方法, 如果有多种基类,  就会有多个 函数/方法,   而 抽象工厂方法模式 就是将这 多个 函数/方法封装起来的方法; 通过提供一个基类, 里面有多个方法,  每个方法负责创建属于自己的一片天地. 
  * 场景: 原料工厂
    * 存在不同的原料: 面团, 酱汁, 芝士
    * 同一种原料也存在不同的 口味: 番茄酱料, 水果酱料...
  * 做法: 
    * 实现一个原料工厂接口, 里面有创建 不同原料的 抽象方法
    * 不同的厂家继承 这个 接口,  来创建他们自己的 口味的 原料

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

