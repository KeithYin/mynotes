# chapter 1



* 当涉及到维护时，为了复用（reuse）而使用继承的结局并不完美！ **因为可能某些子类并不具有超类的一些方法** ， 比如，鸭子的 `飞` 方法， 橡皮鸭可不会飞。
* 如果有一种建立软件的方法，好让我们对 **既有的代码影响最小的方式来修改** 软件该有多好。



**关于鸭子**

模拟鸭子游戏：需要各种各样的鸭子，鸭子可能会有的行为有：

* 飞 （不一定所有的鸭子都能飞，不一定所有的鸭子飞的方式都一样）
  * 不能飞也是飞的一个行为
* 叫 （不一定所有的鸭子都能叫，不一定所有的鸭子叫的方式都一样）
  * 不能叫,  也是叫的一个行为

基于下面给出的设计原则：**找出应用中可能需要的变化之处，将他们独立出来。** 所以我们就需要将 `飞` 和 `叫` 独立出来。建立一组新类来代表每个行为。



|                  | 继承                                                         | 实现接口                                                     | 命令模式                                                     |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 给鸭子加飞的行为 | 基类加上fly方法<br />1. 老代码: 确认当前鸭子是不是可以飞, 如果不能飞, 覆盖基类代码<br />2. 新代码: 确认当前鸭子是不是可以飞, 如果不能飞, 覆盖基类代码 | 鸭子想要具有什么功能, 就实现哪个接口<br />1. 老代码: 确定是否需要实现飞行接口, 并实现之<br />2. 新代码: 确定是否需要飞行接口, 并实现之 | 鸭子想要什么行为, 就在基类中添加对应的接口, 然后为该接口实现一族类<br />1. 老代码: 需要给对应的接口赋值<br />2. 新代码: 需要给对应的接口赋值 |
| 优缺点           | 优点: 代码可以复用<br />缺点: 每次添加新鸭子类都要考虑是不是需要重写fly方法; 不需要fly的老代码都需要修改 | 优点: 需要fly能力的鸭子仅需要实现该接口即可<br />缺点: 由于java接口不带实现, 所以代码无法复用... (C++就没这个问题了) | 优点:行为类代码可以复用, 鸭子类可以很容易的改变行为<br />缺点: 老代码还是得修改, 因为鸭子基类里多了一个接口属性, 需要赋值的. |



**针对接口编程，不要针对实现编程**

```java
Dog g = new Dog(); // 针对实现编程
Animal animal = new Dog(); // 针对接口编程
```



**将实现部分延迟到真正调用的时候，在编程的时候，尽量全部用接口。**



## 设计原则

* 找出应用中**可能需要变化之处**，把他们独立出来，不要让它们和那些不需要变换的代码混在一起
  * 如何找到可能需要变化之处呢？ 每次当**新需求到来的时，需要修改的地方**
    * 按照鸭子举例: 
      * 不同的鸭子具有不同的 叫 行为, **这就是变化的地方**
      * 有些鸭子可以飞, 有些鸭子不能飞, **这也是变化的地方**
  * 把需要变化的部分**取出来并封装**起来， 以便可以轻松的改动或扩充此部分，而不影响其它不需要变化的部分
* 针对**接口**编程， 而不是针对实现编程。（因为所有的子类对象对可以用接口 来接收，这样在接收时就能同意口径），这里感觉应该嫁个条件（对于**变化之处** 针对接口编程）。
  * 这句话隐藏意思是： 实例对象 尽量赋值给 接口对象。
* **多用组合，少用继承**





**所有的设计模式都提供了一套方法：系统中的某部分改变不会影响其它部分！**



## 设计模式

* **策略模式**
  * 定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
* 