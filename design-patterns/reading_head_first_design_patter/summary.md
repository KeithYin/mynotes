# 设计模式总结



## 设计原则总结

* 找出应用中 **可能变化** 之处，把他们 **独立出来**，不要和那些不需要变化的代码放在一起。

  * 把会变化的部分 **取出并封装** 起来 ，好让其他部分不会受到影响。

    ​

* 针对接口（**超类/基类**）编程，而不是针对实现编程

  * 在写代码的时候，**形参最好都是接口**，不要用具体的实现，这样的话，可以用简单的任意的实现来给这个 **形参传值 **。 





* **多用组合**, 少用**继承**
* 为了交互对象的 **松耦合** 而努力
* **类应该对扩展开放，对修改关闭** 
* **依赖抽象，不要依赖具体类**
* ​


## 设计模式总结

----



## 策略模式

**定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户**

* `定义了算法族`： 定义了多个算法类，他们都继承同一个基类
* `可以相互替换`： 因为继承了同一个基类，所以他们之间可以相互替换



## 观察者模式

**特点**

* 让对象知悉现状，不会错过对象感兴趣的事。
* 对象甚至可决定在运行时是是否要继续被通知



**通过例子理解观察者模式**

* 报社的任务是出版报纸
* 向某家报社订阅报纸，如果他们一旦有新报纸，他们就会给你送过去
* 当不想看到报纸时，可以取消订阅

**出版社+订阅者=观察者模式**

* 出版社： 主题
* 订阅者：观察者



**关系**

* 观察者可以订阅主题
* 观察者可以取消订阅主题
* 主题会给订阅的观察者发送消息



**正式定义： 定义了对象的一对多（主题-->观察者）依赖关系，这样一来，当主题改变状态时，它的所有依赖者都会收到通知。**



**实现**

```python
class Subject(object):
    def __init__(self):
        self.observers = []
    def registe_observer(self, o):
        self.observers.append(o)
    def remove_observer(self, o):
        del self.observers[self.observers.index(o)]
    def notify_all(self):
        for obs in self.observers:
            obs.do_something()

class Observer(object):
    def do_something():
        # 当主题通知变化时，应该做什么
        pass
```



## 装饰者模式

**目标**

* 在不修改现有代码的情况下，就可搭配新的行为。



**定义：动态的（意思就是在运行时）将责任附加在对象上。若要扩展功能，装饰者提供了比继承更加有弹性的方案**

* 实际上就是用组合

**实现**

```python
# Decorater 和具体的 Component 都要继承同一个 Component
```



## 工厂模式

**既然一直再说针对接口编程， 那么总要有地方创建实例吧，工厂模式就是答案**



## 单例模式

**You are my only one ! **



## 命令模式

**封装调用**



**动作的请求者 与 动作的执行者 解耦， 因为动作的执行者变化可能会很多**



**考虑一个场景**

有一家餐馆，客人来之后会点餐，服务员会将订单交给厨师，厨师拿着订单做菜。

* 客人： 客户
* 服务员：调用者
* 厨师：接收者、执行者
* 订单：命令对象



在命令模式中，有几个关键点：

* 客户（这个不是个对象）：创建命令对象，与接收者绑定。
* 命令对象（命令模式中的对象）：命令对象其实是个动作，它同时绑定了命令的接收者（执行者）
  * 命令对象有个 `execute()` 方法，用来调用 `接收者`，动作
* 调用者对象（命令模式中的对象）：有个 `setCommand()` 方法，将 `Command` 传给 自己
* 接收者（命令模式中的对象）：实际的操作者

**可以看出，调用者对象 将调用封装起来了。 命令将要执行啥，和由谁执行封装起来。调用者来调用命令中的执行接口，实际上是执行的接收者的执行接口**



## 适配器模式



